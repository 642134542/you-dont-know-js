# 第三章 对象

<!-- TOC -->

- [第三章 对象](#第三章-对象)
  - [语法](#语法)
  - [类型](#类型)
    - [内置对象](#内置对象)
      - [文字形式和构造形式](#文字形式和构造形式)
  - [对象的内容](#对象的内容)
    - [可计算的属性名](#可计算的属性名)
    - [浅拷贝和深拷贝](#浅拷贝和深拷贝)

<!-- /TOC -->

## 语法

对象的定义, 有两种形式:

- 声明形式

``` javascript
var obj = {
  key: 'value'
}
```

- 构造形式

``` javascript
var obj = new Object()
obj.key = 'value'
```

## 类型

> `JavaScript` 中一共有 `6` 种基本类型(语言类型)

- string
- number
- **object**
- boolean
- null
- undefined

对象就是其中的一种, 我们可以使用 `typeof` 语句来判断某变量属于什么类型

``` javascript
typeof 'str'     // < "string"
typeof 1         // < "number"
typeof true      // < "boolean"
typeof undefined // < "undefined"

typeof {}        // < "object"
typeof []        // < "object"
typeof null      // < "object"

typeof function(){}  // < "function"
```

> 原来数组也是对象

我们经常会遇到判断某个变量是 数组还是对象, 这让我们自然而然觉得数组应该是一种基本类型;

我们可以由 `typeof []` 的返回值看出, 实际上数组也是 `object` 类型, 它也具备一些额外的行为, 并且其组织方式比一般的对象要稍微复杂一些;

以下就是数组作为对象时所表现出的行为的铁证!

`[].length`

`[].map(...)`

``` javascript
[1, 2].length      // 2

[1, 2].map(...)

var a = [1, 2, 3]  // (3)[1, 2, 3]
a.bar = 4          // (4)[1, 2, 3, bar: 4]
a.bar              // 4
```

> 为什么 `null` 的类型也是 `object`?

`null` 有时会被当做对象, 这其实是语言本身的一个 `bug`, 不同的对象在底层都表示为二进制, `JavaScript` 中二进制前三位都为0的话, 会判断为 `object` 类型, `null` 的二进制表示全是 0, 自然前三位也是 0, 所以执行 `typeof` 时会返回 `object`

### 内置对象

- String
- Number
- Boolean
- Object
- Function
- Array
- Date
- RegExp
- Error

他们实际上只是一些内置函数, 这些内置函数可以当做构造函数来使用, 如: `var str = new String('str')`

#### 文字形式和构造形式

我们在声明一个变量时, 通常是可以选择**文字形式**或**构造形式**声明的, 如下:

**文字形式**

``` javascript
var str = 'str'     // type = "string"
var boolean = true  // type = "boolean"
var num = 1         // type = "number"
var obj = {}        // type = "object"
var arr = []        // type = "object"
```

**构造形式**

``` javascript
var str = new String('str')     // type = "object"
var boolean = new Boolean(true) // type = "object"
var number = new Number(1)      // type = "object"
var obj = new Object({})        // type = "object"
var arr = new Array(1, 2)       // type = "object"
```

我们可以看到, **文字形式** 声明的 字符串, 布尔值, 数值, 他们都对应的是自己的基础类型, 这些类型只是普通的**字面量**, 他们是不具备任何方法的;

> 但事实上, 我么可以通过 `'str'.length` 的方式, 访问到该字符串的长度, 这是为什么?

这是因为, 引擎会自动把字符串字面量转换成一个 `String` 对象, 所以我们才可以访问字符串的属性和方法, 同样, 布尔值和数值也是.

**总的来说:**
- String, Boolean, Number 的**文字形式**, 会被引擎自动转换为**构造形式**的对象
- null, undefined 没有对应的**构造形式**, 它们只有**文字形式**
- Date 只有**构造形式**
- Object, Array, Function, RegExp, 无论使用**文字形式**还是**构造形式**, 它们都是对象, 不是字面量

## 对象的内容

> 对象的内容是由一些存储在特定命名位置的值(任意类型)组成的, 我们称之为属性;

> 当我们说内容的时候, 似乎暗示它们是存储在对象内部的, 但实际上存储在对象容器内部的只有这些**属性的名称**, 这些名称就是**指针**, 指向值真正存储的位置

对对象属性的访问, 有两种形式:

`var obj = { a: 1 }`

- 属性访问: `obj.a`
- 键访问: `obj['a']`

### 可计算的属性名

> 可以在文字形式中使用 [] 包裹一个表达式来当作属性名:

``` javascript
var prefix = 'foo'

var obj = {
  foobar: 1,
  foobaz: 2
}

obj[`${prefix}bar`]  // 1
obj[`${prefix}baz`]  // 2
```

> ES6 增加了*可计算属性名*:

``` javascript
var prefix = 'foo'

var obj = {
  [`${prefix}bar`]: 1,
  [`${prefix}baz`]: 2
}

obj.foobar     // < 1
obj['foobar']  // < 1
obj['foobaz']  // < 2
```

### 浅拷贝和深拷贝

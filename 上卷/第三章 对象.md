# 第三章 对象

<!-- TOC -->

- [第三章 对象](#第三章-对象)
  - [语法](#语法)
  - [类型](#类型)
    - [内置对象](#内置对象)
      - [文字形式和构造形式](#文字形式和构造形式)
  - [对象的内容](#对象的内容)
    - [可计算的属性名](#可计算的属性名)
    - [浅拷贝和深拷贝](#浅拷贝和深拷贝)
      - [浅拷贝](#浅拷贝)
        - [Object.assign(...)](#objectassign)
      - [深拷贝](#深拷贝)
    - [属性描述符](#属性描述符)
      - [描述符的三个特性](#描述符的三个特性)
      - [描述符方法](#描述符方法)
      - [getter setter 和 双向绑定](#getter-setter-和-双向绑定)
        - [getter setter](#getter-setter)
        - [双向绑定](#双向绑定)

<!-- /TOC -->

## 语法

对象的定义, 有两种形式:

- 声明形式

``` javascript
var obj = {
  key: 'value'
}
```

- 构造形式

``` javascript
var obj = new Object()
obj.key = 'value'
```

## 类型

> `JavaScript` 中一共有 `6` 种基本类型(语言类型)

- string
- number
- **object**
- boolean
- null
- undefined

对象就是其中的一种, 我们可以使用 `typeof` 语句来判断某变量属于什么类型

``` javascript
typeof 'str'     // < "string"
typeof 1         // < "number"
typeof true      // < "boolean"
typeof undefined // < "undefined"

typeof {}        // < "object"
typeof []        // < "object"
typeof null      // < "object"

typeof function(){}  // < "function"
```

> 原来数组也是对象

我们经常会遇到判断某个变量是 数组还是对象, 这让我们自然而然觉得数组应该是一种基本类型;

我们可以由 `typeof []` 的返回值看出, 实际上数组也是 `object` 类型, 它也具备一些额外的行为, 并且其组织方式比一般的对象要稍微复杂一些;

以下就是数组作为对象时所表现出的行为的铁证!

`[].length`

`[].map(...)`

``` javascript
[1, 2].length      // 2

[1, 2].map(...)

var a = [1, 2, 3]  // (3)[1, 2, 3]
a.bar = 4          // (4)[1, 2, 3, bar: 4]
a.bar              // 4
```

> 为什么 `null` 的类型也是 `object`?

`null` 有时会被当做对象, 这其实是语言本身的一个 `bug`, 不同的对象在底层都表示为二进制, `JavaScript` 中二进制前三位都为0的话, 会判断为 `object` 类型, `null` 的二进制表示全是 0, 自然前三位也是 0, 所以执行 `typeof` 时会返回 `object`

### 内置对象

- String
- Number
- Boolean
- Object
- Function
- Array
- Date
- RegExp
- Error

他们实际上只是一些内置函数, 这些内置函数可以当做构造函数来使用, 如: `var str = new String('str')`

#### 文字形式和构造形式

我们在声明一个变量时, 通常是可以选择**文字形式**或**构造形式**声明的, 如下:

**文字形式**

``` javascript
var str = 'str'     // type = "string"
var boolean = true  // type = "boolean"
var num = 1         // type = "number"
var obj = {}        // type = "object"
var arr = []        // type = "object"
```

**构造形式**

``` javascript
var str = new String('str')     // type = "object"
var boolean = new Boolean(true) // type = "object"
var number = new Number(1)      // type = "object"
var obj = new Object({})        // type = "object"
var arr = new Array(1, 2)       // type = "object"
```

我们可以看到, **文字形式** 声明的 字符串, 布尔值, 数值, 他们都对应的是自己的基础类型, 这些类型只是普通的**字面量**, 他们是不具备任何方法的;

> 但事实上, 我么可以通过 `'str'.length` 的方式, 访问到该字符串的长度, 这是为什么?

这是因为, 引擎会自动把字符串字面量转换成一个 `String` 对象, 所以我们才可以访问字符串的属性和方法, 同样, 布尔值和数值也是.

**总的来说:**
- String, Boolean, Number 的**文字形式**, 会被引擎自动转换为**构造形式**的对象
- null, undefined 没有对应的**构造形式**, 它们只有**文字形式**
- Date 只有**构造形式**
- Object, Array, Function, RegExp, 无论使用**文字形式**还是**构造形式**, 它们都是对象, 不是字面量

## 对象的内容

> 对象的内容是由一些存储在特定命名位置的值(任意类型)组成的, 我们称之为属性;

> 当我们说内容的时候, 似乎暗示它们是存储在对象内部的, 但实际上存储在对象容器内部的只有这些**属性的名称**, 这些名称就是**指针**, 指向值真正存储的位置

对对象属性的访问, 有两种形式:

`var obj = { a: 1 }`

- 属性访问: `obj.a`
- 键访问: `obj['a']`

### 可计算的属性名

> 可以在文字形式中使用 [] 包裹一个表达式来当作属性名:

``` javascript
var prefix = 'foo'

var obj = {
  foobar: 1,
  foobaz: 2
}

obj[`${prefix}bar`]  // 1
obj[`${prefix}baz`]  // 2
```

> ES6 增加了*可计算属性名*:

``` javascript
var prefix = 'foo'

var obj = {
  [`${prefix}bar`]: 1,
  [`${prefix}baz`]: 2
}

obj.foobar     // < 1
obj['foobar']  // < 1
obj['foobaz']  // < 2
```

### 浅拷贝和深拷贝

#### 浅拷贝

JavaScript 引擎为了避免一次性复制过大的**对象副本**, 在对**对象**进行赋值时, 只是`引用`了目标对象的内存地址, 并没有创建全新的副本

``` javascript
var foo = {
    name: 'muzi'
}

var bar = { foo: foo }

bar.foo.name = 'yaya'
console.log(foo.name)  // yaya

foo.name = 'dundun'
console.log(bar.foo.name)  // dundun
```

无论你通过何种途径去修改 原始对象 `foo` 中的属性值, 操作都将同步到原始对象以及引用该对象的变量上.

##### Object.assign(...)

ES6 定义了 `Object.assign` 方法来实现浅拷贝, 该方法的第一个参数是**目标对象**, 之后可以跟多个源对象;

它会遍历一个或多个源对象的所有**可枚举**的自有键, 并把它们复制 *(使用 = 操作符赋值)* 到目标对象, 最后返回目标对象;

仔细看以下案例:

``` javascript
var foo = {
    name: 'muzi',
    info: {
        age: 25,
        local: 'cq'
    }
}

var bar = Object.assign({}, foo)
bar.name = 'yaya'
bar.info.local = 'bj'

console.log(bar.name)  // yaya
console.log(foo.name)  // muzi

console.log(bar.info.local)  // bj
console.log(foo.info.local)  // bj
```

- 脚本首先会遍历 `foo` 对象中所有可枚举的属性
- 将 `foo.name` 赋值给 `bar`, 这是一个普通的**字面量赋值**, 所以脚本会为 `bar` 创建一个全新的属性
- 将 `foo.info` 赋值给 `bar`, 这是一个对象赋值, 所以 `bar` 只是引用了 `foo.info` 对象

> `Object.assign` 的行为:

``` javascript
var foo = {
    info: {
        name: 'muzi',
        age: 25
    }
}

var bar = {
    id: '123',
    info: {
        name: 'yaya',
        age: 29
    }
}

var baz = Object.assign({
    info: {
        name: 'dundun',
        age: 2,
        local: 'cq',
        attr: 'dog'
    }
}, foo, bar)

console.log(baz)  // { id: '123', info: { name: 'yaya', age: 29 } }
```

- `Object.assign` 会以最后一个**源对象**为最优先赋值
- 最后一个**源对象**会完全替换之前对象已有的属性, 保留没有的属性

#### 深拷贝

但是这对于普通字面量的值就不同了, 新的对象会完全拷贝旧对象中的值, 作为一个新的属性存在, 如下:

``` javascript
var name = 'muzi'

var person = {
  name: name,
  age: 25
}

person.name = 'yaya'
console.log(name)  // muzi
console.log(person.name)  // yaya
```

> 由此我们能得到一个巧妙的进行`深拷贝`的方法:

``` javascript
var num = 1

var foo = {
    name: 'muzi'
}

var bar = {
    foo: JSON.parse(JSON.stringify(foo))
}

bar.foo.name = 'yaya'
console.log(bar.foo.name)  // yaya
console.log(foo.name)      // muzi
```

我们将原始对象转换成一个`JSON 字符串`, 再将该字符串解析成一个结构与原始对象一模一样的对象, 完成了`深拷贝`

### 属性描述符

> 从 ES5 开始, JavaScript 提供了可以直接检测或设置属性特性的方法, 比如判断属性是否可读

#### 描述符的三个特性

- `writable` 可写, 决定属性是否可以修改属性的值
- `enumberable` 可枚举, 决定属性能否被枚举, 如果为 false, 则在 `for...in` 循环中不会枚举出该属性
- `configurable` 可配置, 该值为 `true` 时, 才能使用 `Object.defineProperty` 进行修改, 需要注意的是, 把 `configurable` 修改成 false 是单向操作, 无法撤销!

#### 描述符方法

- Object.**getOwnPropertyDescriptor**(obj = `Object`, property = `String`)
返回目标对象属性的所有特性

``` javascript
var obj = { name: 'muzi' }
console.log(Object.getOwnPropertyDescriptor(obj, 'name'))

// {
//     value: 'muzi',      # 值
//     writable: true,     # 可写
//     enumerable: true,   # 可枚举
//     configurable: true  # 可配置
// }
```

- Object.**defineProperty**(obj = `Object`, property = `String`, descriptor = `Object`)
用于定义一个新属性, 或者修改一个已有属性的值或特性(如果它的 configurable 为 true 的话)

``` javascript
var obj = { name: 'muzi' }

Object.defineProperty(obj, 'name', {
  value: 'yaya',
  writable: false  // 不可写
})

obj.name = 'dundun'
console.log(obj.name)  // yaya
```

``` javascript
var obj = { name: 'muzi' }

Object.defineProperty(obj, 'age', {
  value: 25,
  writable: true,
  enumerable: false  // 不可枚举
})

console.log(obj.age)  // 25

for (var key in obj) {
  console.log(key)  // name
}
```

- Object.**defineProperties**(obj = `Object`, descriptors = `Object`)
用于定义或修改某个对象多个属性

``` javascript
var obj = { name: 'muzi' }
Object.defineProperties(obj, {
  // 修改 name 属性
  name: {
    value: 'yaya',
    enumerable: false
  },
  // 新增 age 属性
  age: {
    value: 25,
    writable: false
  }
})

console.log(obj.name) // muzi
console.log(obj.age)  // 25
```

#### getter setter 和 双向绑定

##### getter setter

> `getter` 和 `setter` 是两个隐藏函数, 分别在**获取属性**和**设置属性**时被调用

``` javascript
var obj = {}

Object.defineProperty(obj, 'name', {
  get() {
    console.log('execute getter')
    return this._name_ || 'muzi'
  },
  set(newVal) {
    console.log('execute setter')
    this._name_ = newVal
  }
})

> obj.name
< "execute getter"
< "muzi"
> obj.name = 'yaya'
< "execute setter"
< "yaya"
```

`get` 和 `set` 函数, 能够在访问或设置对象属性时, 进行拦截, 这意味着我们可以在这个过程中做很多事, 比如可以在设置属性值的时候进行运算:

``` javascript
var obj = {}
Object.defineProperty(obj, 'name', {
    get() {
        return this._name_ || 'Tom Jack'
    },
    set(newVal) {
        var firstName = 'Tom'
        this._name_ = firstName + ' ' + newVal
    }
})

obj.name = 'Hannibal'
console.log(obj.name) // Tom Hannibal
```

##### 双向绑定

这里简单提一下 `MVVM`, 它是 `Model-View-ViewModel` 的缩写, 这种模式将 `Model`(数据) 和 `View`(前端显示) 最大限度的分离, 而 `ViewModel`(双向绑定) 则负责将两者关联起来.

看以下示例:

``` html
<body>
  <p id="el"></p>
  <input id="model" type="text" placeholder="type your name." />
</body>
```

``` javascript
var doc = document
var el = doc.getElementById('el')
var model = doc.getElementById('model')

// 双向绑定
var data = {}
Object.defineProperty(data, 'name', {
  get() {
    console.log('execute getter.')
    return this._name_
  },
  set(newVal) {
    console.log('execute getter')

    el.textContent = newVal
    model.value = newVal

    this._name_ = newVal
  }
})
```

我们在浏览器中打开这个页面, 在控制台输入: `data.name = 'muzi'`, 我们会发现, 对应在页面中的 `Dom` 元素也发生了变化,

我们不需要再在 `javascript` 中操作节点, 并显示为节点赋值, 只需要改变绑定的数据就能同步改变 `Dom`.

如果我们想在用户输入的过程中, 将 `Dom` 的内容与输入内容同步怎么办? 道理很简单, 之所以 `data.name = 'muzi'` 能让 `Dom` 响应式变化, 是因为这是一个赋值操作, 赋值的过程被 `setter` 拦截并赋予了新的行为,

那么, 我们监听 `<input />` 元素每一次的 `keyup` 事件, 并在事件回调中触发 `setter` 不就行了么?

``` javascript
model.addEventListener('keyup', function() {
  data.name = this.value
})
```

打开页面, 在输入框中输入内容, 你会发现 `Dom` 与输入框是完全同步的, `双向绑定` 就是这么简单!
